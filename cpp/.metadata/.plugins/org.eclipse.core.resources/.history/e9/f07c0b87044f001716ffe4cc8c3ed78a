#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include <iostream>
#include <stdlib.h>
#include <boost/python.hpp>
#include "boost/python/extract.hpp"
#include "boost/python/numeric.hpp"
#include <numpy/ndarrayobject.h>
#include <algorithm>
#include <vector>
#include <stdint.h>
#include <assert.h>
#include <immintrin.h>
#include <omp.h>
#include <sstream>


using namespace std;
using namespace boost::python;
typedef uint8_t uint8;
typedef int16_t int16;
typedef unsigned long long int uint64;

#define NCCSIGMA 2*pow(0.1,2)
#define CENSUSSIGMA 2*pow(8.0,2)
#define SADSIGMA 2*pow(100.0,2)

PyObject* extract_testing_features(PyObject* cost_census, PyObject* cost_ncc, PyObject* cost_sad ){
    PyArrayObject* censA = reinterpret_cast<PyArrayObject*>(cost_census);
    PyArrayObject* nccA = reinterpret_cast<PyArrayObject*>(cost_ncc);
    PyArrayObject* sadA = reinterpret_cast<PyArrayObject*>(cost_sad);

    double * censp = reinterpret_cast<double*>(PyArray_DATA(censA));
    double * nccp = reinterpret_cast<double*>(PyArray_DATA(nccA));
    double * sadp = reinterpret_cast<double*>(PyArray_DATA(sadA));

    npy_intp *shapecens = PyArray_DIMS(censA);
    npy_intp *shapencc = PyArray_DIMS(nccA);
    npy_intp *shapesad = PyArray_DIMS(sadA);


    npy_intp *featshape = new npy_intp[2];
    featshape[0] = shapecens[0]*shapecens[1]; featshape[1] = 12;

	PyObject* features = PyArray_SimpleNew(2, featshape, NPY_FLOAT64);

	double* features_data = static_cast<double*>(PyArray_DATA(reinterpret_cast<PyArrayObject*>(features)));

#pragma omp parallel num_threads(12)
	{
		#pragma omp for
		for (int i=0; i <shapecens[0]; i++ ){

			const int pos = i* shapecens[1];
			const int posc = i*shapencc[0];
			double min_ncc = RAND_MAX, min_cens = RAND_MAX, min_sad = RAND_MAX,censdenom=0,nccdenom=0,saddenom=0,num;

			for(int k=0; k< shapecens[1]; k++){
					if(censp[pos+k] < min_cens){
						min_cens = censp[pos+k];
					}
					if(nccp[k*shapencc[1]+i] < min_ncc){
						min_ncc = nccp[k*shapencc[1]+i];
					}
					if(sadp[k*shapesad[1]+i] < min_sad){
						min_sad = sadp[k*shapesad[1]+i];
					}

			}


			for(int k=0; k<shapecens[1]; k++){
					num = censp[pos+k]-min_cens;
					censdenom += exp( -( num*num )/CENSUSSIGMA );
					num =nccp[k*shapencc[1]+i]-min_ncc;
					nccdenom += exp( -( num*num )/NCCSIGMA );
					num = sadp[k*shapesad[1]+i]-min_sad;
					saddenom += exp( -( num*num )/SADSIGMA );
			}


			for(int j=0; j< shapecens[1]; j++){
				//Census cost
				const int s_i = i*shapecens[1]*12 + j*12;
				features_data[ s_i  ] = censp[pos+j];
				//Ncc cost
				features_data[s_i +1] = nccp[j*shapencc[1]+i];
				//Sad cost
				features_data[s_i +2] = sadp[j*shapesad[1]+i];

				//PKRN CENSUS
				features_data[s_i +3] = ( min_cens +.01 ) / (censp[pos+j]+.01);
				assert(  ( min_cens +.01 ) / (censp[pos+j]+.01) > 0);
				//PKRN NCC
				features_data[s_i +4] = ( min_ncc +1.01 ) / (nccp[j*shapencc[1]+i]+1.01);
				assert(  ( min_ncc +1.01 ) / (nccp[pos+j]+1.01) > 0);
				//PKRN SAD
				features_data[s_i +5] = ( min_sad +.01 ) / (sadp[j*shapesad[1]+i]+.01);
				assert(  ( min_sad +1.01 ) / (sadp[pos+j]+1.01) > 0);

				//MMN CENSUS
				features_data[s_i+6] = censp[pos+j] - min_cens;
				//MMN NCC
				features_data[s_i+7] = nccp[j*shapencc[1]+i] - min_ncc;
				//MMN SAD
				features_data[s_i+8] = sadp[j*shapesad[1]+i] - min_sad;

				//AML CENSUS
				features_data[s_i+9] = exp( -((features_data[s_i+6]*features_data[s_i+6]) /CENSUSSIGMA )) /censdenom ;
				//AML NCC
				features_data[s_i+10] = exp( -((features_data[s_i+7]*features_data[s_i+7]) /NCCSIGMA )) /nccdenom ;
				//AML SAD
				features_data[s_i+11] = exp( -((features_data[s_i+8]*features_data[s_i+8]) /SADSIGMA )) /saddenom ;


			}

		}

	}

	return features;
}

PyObject* extract_features(PyObject* cost_census, PyObject* cost_ncc, PyObject* cost_sad , PyObject *gt, PyObject *row_indices ){

	srand (time(NULL));

    PyArrayObject* censA = reinterpret_cast<PyArrayObject*>(cost_census);
    PyArrayObject* nccA = reinterpret_cast<PyArrayObject*>(cost_ncc);
    PyArrayObject* sadA = reinterpret_cast<PyArrayObject*>(cost_sad);
    PyArrayObject* gtA = reinterpret_cast<PyArrayObject*>(gt);
    PyArrayObject* riA = reinterpret_cast<PyArrayObject*>(row_indices);

    double * censp = reinterpret_cast<double*>(PyArray_DATA(censA));
    double * nccp = reinterpret_cast<double*>(PyArray_DATA(nccA));
    double * sadp = reinterpret_cast<double*>(PyArray_DATA(sadA));
    int * gtp = reinterpret_cast<int*>(PyArray_DATA(gtA));
    int * rip = reinterpret_cast<int*>(PyArray_DATA(riA));



    npy_intp *samples = PyArray_DIMS(riA);
    npy_intp *shape = PyArray_DIMS(gtA);
    npy_intp *shapecens = PyArray_DIMS(censA);
    npy_intp *shapencc = PyArray_DIMS(nccA);
    npy_intp *shapesad = PyArray_DIMS(sadA);

    int maxd = shapecens[1];

    npy_intp *featshape = new npy_intp[2];
    featshape[0] = 3*samples[0]; featshape[1] = 13;


	PyObject* features = PyArray_SimpleNew(2, featshape, NPY_FLOAT64);

	double* features_data = static_cast<double*>(PyArray_DATA(reinterpret_cast<PyArrayObject*>(features)));


#pragma omp parallel num_threads(12)
	{
		#pragma omp for
		for (int s=0; s<samples[0]; s++){
			const int i = rip[s];
			double min_ncc = RAND_MAX, min_cens = RAND_MAX, min_sad = RAND_MAX,censdenom=0,nccdenom=0,saddenom=0,num;
			const int pos = i* shapecens[1];
			int ncc_min_pos =0;
			int census_min_pos=0;
			int sad_min_pos=0;
			if(gtp[i] <0 || gtp[i] >= maxd )
				continue;

			for(int k=0; k< maxd; k++){
					if(censp[pos+k] < min_cens){
						min_cens = censp[pos+k];
						census_min_pos=k;
					}
					if(nccp[k*shapencc[1]+i] < min_ncc){
						min_ncc = nccp[k*shapencc[1]+i];
						ncc_min_pos=k;
					}
					if(sadp[k*shapesad[1]+i] < min_sad){
						min_sad = sadp[k*shapesad[1]+i];
						sad_min_pos=k;
					}

			}


			for(int k=0; k<maxd; k++){
					num = censp[pos+k]-min_cens;
					censdenom += exp( -( num*num )/CENSUSSIGMA );
					num =nccp[k*shapencc[1]+i]-min_ncc;
					nccdenom += exp( -( num*num )/NCCSIGMA );
					num = sadp[k*shapesad[1]+i]-min_sad;
					saddenom += exp( -( num*num )/SADSIGMA );
			}


			//cost census
			features_data[s*3*13] = censp[pos+gtp[i]];

			//cost ncc
			features_data[s*3*13+1] = nccp[gtp[i]*shapencc[1]+i];
			//cost sad
			features_data[s*3*13+2] = sadp[gtp[i]*shapesad[1]+i];

			//PKRN CENSUS
			features_data[s*3*13+3] = ( min_cens +.01 ) / (censp[pos+gtp[i]]+.01);
			assert(  ( min_cens +.01 ) / (censp[pos+gtp[i]]+.01) > 0);
			//PKRN NCC
			features_data[s*3*13+4] = ( min_ncc +1.01 ) / (nccp[gtp[i]*shapencc[1]+i]+1.01);
			assert( (( min_ncc +1.01 ) / (nccp[gtp[i]*shapencc[1]+i]+1.01))>0);
			//PKRN SAD
			features_data[s*3*13+5] = ( min_sad +.01 ) / (sadp[gtp[i]*shapesad[1]+i]+.01);
			assert( ( min_sad +.01 ) / (sadp[gtp[i]*shapesad[1]+i]+.01)>0);


			//MMN CENSUS
			features_data[s*3*13+6] = censp[pos+gtp[i]] - min_cens;
			//MMN NCC
			features_data[s*3*13+7] = nccp[gtp[i]*shapencc[1]+i] - min_ncc;
			//MMN SAD
			features_data[s*3*13+8] = sadp[gtp[i]*shapesad[1]+i] - min_sad;

			//AML CENSUS
			features_data[s*3*13+9] = exp( -((features_data[s*3*13+6]*features_data[s*3*13+6]) /CENSUSSIGMA )) /censdenom ;
			//AML NCC
			features_data[s*3*13+10] = exp( -((features_data[s*3*13+7]*features_data[s*3*13+7]) /NCCSIGMA )) /nccdenom ;
			//AML SAD
			features_data[s*3*13+11] = exp( -((features_data[s*3*13+8]*features_data[s*3*13+8]) /SADSIGMA )) /saddenom ;
			//label
			features_data[s*3*13+12] = 1;

			const int disp = gtp[i];
            bool low = true;
            bool high = true;
            if(disp-2 <=0 )
                    low = false;

            if(disp+2 >= maxd)
                    high = false;

            int d1 = 0;
            int d2 = 0;

            if( low ){
            	d1 = rand()%(disp-1);
            }else{
            	d1 = rand()%(maxd - (disp +2)) + disp+2;
            }
            if( high){
            	d2 = rand()%(maxd - (disp +2)) + disp+2;
            }else{
            	d2 = rand()%(disp-1);
            }




			//select a random sample but not in the interval [ gt-1 ,gt+1 ]
//			int s_r = rand()%maxd;
//			while( s_r >= gtp[i]-1 && s_r <= gtp[i]+1 )
//				s_r = rand()%maxd;

			//cost census
			features_data[((s*3)+1)*13] = censp[pos+d1];
			//cost ncc
			features_data[((s*3)+1)*13+1] = nccp[d1*shapencc[1]+i];
			//cost sad
			features_data[((s*3)+1)*13+2] = sadp[d1*shapesad[1]+i];

			//PKRN CENSUS
			features_data[((s*3)+1)*13+3] = ( min_cens +.01 ) / (censp[pos+d1]+.01);
			assert(  ( min_cens +.01 ) / (censp[pos+d1]+.01) > 0);
			//PKRN NCC
			features_data[((s*3)+1)*13+4] = ( min_ncc +1.01 ) / (nccp[d1*shapencc[1]+i]+1.01);
			assert( ( min_ncc +1.01 ) / (nccp[d1*shapencc[1]+i]+1.01)>0);
			//PKRN SAD
			features_data[((s*3)+1)*13+5] = ( min_sad +.01 ) / (sadp[d1*shapesad[1]+i]+.01);
			assert( ( min_sad +.01 ) / (sadp[d1*shapesad[1]+i]+.01)>0);


			//MMN CENSUS
			features_data[((s*3)+1)*13+6] = censp[pos+d1] - min_cens;
			//MMN NCC
			features_data[((s*3)+1)*13+7] = nccp[d1*shapencc[1]+i] - min_ncc;
			//MMN SAD
			features_data[((s*3)+1)*13+8] = sadp[d1*shapesad[1]+i] - min_sad;

			//AML CENSUS
			features_data[((s*3)+1)*13+9] = exp( -((features_data[((s*3)+1)*13+6]*features_data[((s*3)+1)*13+6]) /CENSUSSIGMA )) /censdenom ;
			//AML NCC
			features_data[((s*3)+1)*13+10] = exp( -((features_data[((s*3)+1)*13+7]*features_data[((s*3)+1)*13+7]) /NCCSIGMA )) /nccdenom ;
			//AML SAD
			features_data[((s*3)+1)*13+11] = exp( -((features_data[((s*3)+1)*13+8]*features_data[((s*3)+1)*13+8]) /SADSIGMA )) /saddenom ;
			//label
			features_data[((s*3)+1)*13+12] = 0;



//			//Get a strong wrong candidate based on a random matcher
//			int m_r = rand()%3;
//
//			// 0->census, 1->ncc, 2->sad
//			int strong_pos=0;
//			double strong_min = RAND_MAX;
//
//			if(m_r == 0){
//				for(int k=0; k<maxd; k++){
//					if ((k >= census_min_pos -1 && k<=census_min_pos +1) || (k >= gtp[i]-1 && k <= gtp[i]+1))
//						continue;
//					if( censp[pos+k] < strong_min  ){
//						strong_min = censp[pos+k];
//						strong_pos = k;
//					}
//				}
//			}else if( m_r == 1 ){
//				for(int k=0; k<maxd; k++){
//					if ( (k >= ncc_min_pos-1 && k<=ncc_min_pos+1 ) || (k >= gtp[i]-1 && k <= gtp[i]+1))
//						continue;
//					if( nccp[k*shapencc[1]+i] < strong_min  ){
//						strong_min = nccp[k*shapencc[1]+i];
//						strong_pos = k;
//					}
//				}
//			}else{
//
//				for(int k=0; k<maxd; k++){
//					if ((k >= sad_min_pos-1 && k<=sad_min_pos+1  ) || (k >= gtp[i]-1 && k <= gtp[i]+1))
//						continue;
//					if( sadp[k*shapesad[1]+i] < strong_min  ){
//						strong_min = sadp[k*shapesad[1]+i];
//						strong_pos = k;
//					}
//				}
//			}


			//cost census
			features_data[((s*3)+2)*13] = censp[pos+d2];
			//cost ncc
			features_data[((s*3)+2)*13+1] = nccp[d2*shapencc[1]+i];
			//cost sad
			features_data[((s*3)+2)*13+2] = sadp[d2*shapesad[1]+i];

			//PKRN CENSUS
			features_data[((s*3)+2)*13+3] = ( min_cens +.01 ) / (censp[pos+d2]+.01);
			assert(  ( min_cens +.01 ) / (censp[pos+d2]+.01) > 0);
			//PKRN NCC
			features_data[((s*3)+2)*13+4] = ( min_ncc +1.01 ) / (nccp[d2*shapencc[1]+i]+1.01);
			assert( ( min_ncc +1.01 ) / (nccp[d2*shapencc[1]+i]+1.01)>0);
			//PKRN SAD
			features_data[((s*3)+2)*13+5] = ( min_sad +.01 ) / (sadp[d2*shapesad[1]+i]+.01);
			assert( ( min_sad +.01 ) / (sadp[d2*shapesad[1]+i]+.01)>0);


			//MMN CENSUS
			features_data[((s*3)+2)*13+6] = censp[pos+d2] - min_cens;
			//MMN NCC
			features_data[((s*3)+2)*13+7] = nccp[d2*shapencc[1]+i] - min_ncc;
			//MMN SAD
			features_data[((s*3)+2)*13+8] = sadp[d2*shapesad[1]+i] - min_sad;

			//AML CENSUS
			features_data[((s*3)+2)*13+9] = exp( -((features_data[((s*3)+2)*13+6]*features_data[((s*3)+2)*13+6]) /CENSUSSIGMA )) /censdenom ;
			//AML NCC
			features_data[((s*3)+2)*13+10] = exp( -((features_data[((s*3)+2)*13+7]*features_data[((s*3)+2)*13+7]) /NCCSIGMA )) /nccdenom ;
			//AML SAD
			features_data[((s*3)+2)*13+11] = exp( -((features_data[((s*3)+2)*13+8]*features_data[((s*3)+2)*13+8]) /SADSIGMA )) /saddenom ;
			//label
			features_data[((s*3)+2)*13+12] = 0;


		}
	}

	return features;
}

PyObject* extract_features_old(PyObject* cost_census, PyObject* cost_ncc, PyObject* cost_sad , PyObject *gt, PyObject *row_indices ){

	srand (time(NULL));

    PyArrayObject* censA = reinterpret_cast<PyArrayObject*>(cost_census);
    PyArrayObject* nccA = reinterpret_cast<PyArrayObject*>(cost_ncc);
    PyArrayObject* sadA = reinterpret_cast<PyArrayObject*>(cost_sad);
    PyArrayObject* gtA = reinterpret_cast<PyArrayObject*>(gt);
    PyArrayObject* riA = reinterpret_cast<PyArrayObject*>(row_indices);

    double * censp = reinterpret_cast<double*>(PyArray_DATA(censA));
    double * nccp = reinterpret_cast<double*>(PyArray_DATA(nccA));
    double * sadp = reinterpret_cast<double*>(PyArray_DATA(sadA));
    int * gtp = reinterpret_cast<int*>(PyArray_DATA(gtA));
    int * rip = reinterpret_cast<int*>(PyArray_DATA(riA));



    npy_intp *samples = PyArray_DIMS(riA);
    npy_intp *shape = PyArray_DIMS(gtA);
    npy_intp *shapecens = PyArray_DIMS(censA);
    npy_intp *shapencc = PyArray_DIMS(nccA);
    npy_intp *shapesad = PyArray_DIMS(sadA);

    int maxd = shapecens[1];

    npy_intp *featshape = new npy_intp[2];
    featshape[0] = 3*samples[0]; featshape[1] = 13;

	PyObject* features = PyArray_SimpleNew(2, featshape, NPY_FLOAT64);

	double* features_data = static_cast<double*>(PyArray_DATA(reinterpret_cast<PyArrayObject*>(features)));


#pragma omp parallel num_threads(12)
	{
		#pragma omp for
		for (int s=0; s<samples[0]; s++){


			const int i = rip[s];
			const int disp = gtp[i];
			if(disp <0 || disp >= maxd )
				continue;

			int ofc = rand()%3 -1;
            if((disp+ofc) <0){
                    ofc = 0;
            }else if((disp+ofc)>=maxd){
                    ofc=0;
            }



			double min_ncc = RAND_MAX, min_cens = RAND_MAX, min_sad = RAND_MAX,censdenom=0,nccdenom=0,saddenom=0,num;

			const int pos = i* shapecens[1];
			int ncc_min_pos =0;
			int census_min_pos=0;
			int sad_min_pos=0;


			for(int k=0; k< maxd; k++){
					if(censp[pos+k] < min_cens){
						min_cens = censp[pos+k];
						census_min_pos=k;
					}
					if(nccp[k*shapencc[1]+i] < min_ncc){
						min_ncc = nccp[k*shapencc[1]+i];
						ncc_min_pos=k;
					}
					if(sadp[k*shapesad[1]+i] < min_sad){
						min_sad = sadp[k*shapesad[1]+i];
						sad_min_pos=k;
					}

			}


			for(int k=0; k<maxd; k++){
					num = censp[pos+k]-min_cens;
					censdenom += exp( -( num*num )/CENSUSSIGMA );
					num =nccp[k*shapencc[1]+i]-min_ncc;
					nccdenom += exp( -( num*num )/NCCSIGMA );
					num = sadp[k*shapesad[1]+i]-min_sad;
					saddenom += exp( -( num*num )/SADSIGMA );
			}


			//cost census
			features_data[s*3*13] = censp[pos+gtp[i]];

			//cost ncc
			features_data[s*3*13+1] = nccp[gtp[i]*shapencc[1]+i];
			//cost sad
			features_data[s*3*13+2] = sadp[gtp[i]*shapesad[1]+i];

			//PKRN CENSUS
			features_data[s*3*13+3] = ( min_cens +.01 ) / (censp[pos+gtp[i]]+.01);
			assert(  ( min_cens +.01 ) / (censp[pos+gtp[i]]+.01) > 0);
			//PKRN NCC
			features_data[s*3*13+4] = ( min_ncc +1.01 ) / (nccp[gtp[i]*shapencc[1]+i]+1.01);
			assert( (( min_ncc +1.01 ) / (nccp[gtp[i]*shapencc[1]+i]+1.01))>0);
			//PKRN SAD
			features_data[s*3*13+5] = ( min_sad +.01 ) / (sadp[gtp[i]*shapesad[1]+i]+.01);
			assert( ( min_sad +.01 ) / (sadp[gtp[i]*shapesad[1]+i]+.01)>0);


			//MMN CENSUS
			features_data[s*3*13+6] = censp[pos+gtp[i]] - min_cens;
			//MMN NCC
			features_data[s*3*13+7] = nccp[gtp[i]*shapencc[1]+i] - min_ncc;
			//MMN SAD
			features_data[s*3*13+8] = sadp[gtp[i]*shapesad[1]+i] - min_sad;

			//AML CENSUS
			features_data[s*3*13+9] = exp( -((features_data[s*3*13+6]*features_data[s*3*13+6]) /CENSUSSIGMA )) /censdenom ;
			//AML NCC
			features_data[s*3*13+10] = exp( -((features_data[s*3*13+7]*features_data[s*3*13+7]) /NCCSIGMA )) /nccdenom ;
			//AML SAD
			features_data[s*3*13+11] = exp( -((features_data[s*3*13+8]*features_data[s*3*13+8]) /SADSIGMA )) /saddenom ;
			//label
			features_data[s*3*13+12] = 1;

			const int disp = gtp[i];
            bool low = true;
            bool high = true;
            if(disp-2 <=0 )
                    low = false;

            if(disp+2 >= maxd)
                    high = false;

            int d1 = 0;
            int d2 = 0;

            if( low ){
            	d1 = rand()%(disp-1);
            }else{
            	d1 = rand()%(maxd - (disp +2)) + disp+2;
            }
            if( high){
            	d2 = rand()%(maxd - (disp +2)) + disp+2;
            }else{
            	d2 = rand()%(disp-1);
            }




			//select a random sample but not in the interval [ gt-1 ,gt+1 ]
//			int s_r = rand()%maxd;
//			while( s_r >= gtp[i]-1 && s_r <= gtp[i]+1 )
//				s_r = rand()%maxd;

			//cost census
			features_data[((s*3)+1)*13] = censp[pos+d1];
			//cost ncc
			features_data[((s*3)+1)*13+1] = nccp[d1*shapencc[1]+i];
			//cost sad
			features_data[((s*3)+1)*13+2] = sadp[d1*shapesad[1]+i];

			//PKRN CENSUS
			features_data[((s*3)+1)*13+3] = ( min_cens +.01 ) / (censp[pos+d1]+.01);
			assert(  ( min_cens +.01 ) / (censp[pos+d1]+.01) > 0);
			//PKRN NCC
			features_data[((s*3)+1)*13+4] = ( min_ncc +1.01 ) / (nccp[d1*shapencc[1]+i]+1.01);
			assert( ( min_ncc +1.01 ) / (nccp[d1*shapencc[1]+i]+1.01)>0);
			//PKRN SAD
			features_data[((s*3)+1)*13+5] = ( min_sad +.01 ) / (sadp[d1*shapesad[1]+i]+.01);
			assert( ( min_sad +.01 ) / (sadp[d1*shapesad[1]+i]+.01)>0);


			//MMN CENSUS
			features_data[((s*3)+1)*13+6] = censp[pos+d1] - min_cens;
			//MMN NCC
			features_data[((s*3)+1)*13+7] = nccp[d1*shapencc[1]+i] - min_ncc;
			//MMN SAD
			features_data[((s*3)+1)*13+8] = sadp[d1*shapesad[1]+i] - min_sad;

			//AML CENSUS
			features_data[((s*3)+1)*13+9] = exp( -((features_data[((s*3)+1)*13+6]*features_data[((s*3)+1)*13+6]) /CENSUSSIGMA )) /censdenom ;
			//AML NCC
			features_data[((s*3)+1)*13+10] = exp( -((features_data[((s*3)+1)*13+7]*features_data[((s*3)+1)*13+7]) /NCCSIGMA )) /nccdenom ;
			//AML SAD
			features_data[((s*3)+1)*13+11] = exp( -((features_data[((s*3)+1)*13+8]*features_data[((s*3)+1)*13+8]) /SADSIGMA )) /saddenom ;
			//label
			features_data[((s*3)+1)*13+12] = 0;



//			//Get a strong wrong candidate based on a random matcher
//			int m_r = rand()%3;
//
//			// 0->census, 1->ncc, 2->sad
//			int strong_pos=0;
//			double strong_min = RAND_MAX;
//
//			if(m_r == 0){
//				for(int k=0; k<maxd; k++){
//					if ((k >= census_min_pos -1 && k<=census_min_pos +1) || (k >= gtp[i]-1 && k <= gtp[i]+1))
//						continue;
//					if( censp[pos+k] < strong_min  ){
//						strong_min = censp[pos+k];
//						strong_pos = k;
//					}
//				}
//			}else if( m_r == 1 ){
//				for(int k=0; k<maxd; k++){
//					if ( (k >= ncc_min_pos-1 && k<=ncc_min_pos+1 ) || (k >= gtp[i]-1 && k <= gtp[i]+1))
//						continue;
//					if( nccp[k*shapencc[1]+i] < strong_min  ){
//						strong_min = nccp[k*shapencc[1]+i];
//						strong_pos = k;
//					}
//				}
//			}else{
//
//				for(int k=0; k<maxd; k++){
//					if ((k >= sad_min_pos-1 && k<=sad_min_pos+1  ) || (k >= gtp[i]-1 && k <= gtp[i]+1))
//						continue;
//					if( sadp[k*shapesad[1]+i] < strong_min  ){
//						strong_min = sadp[k*shapesad[1]+i];
//						strong_pos = k;
//					}
//				}
//			}


			//cost census
			features_data[((s*3)+2)*13] = censp[pos+d2];
			//cost ncc
			features_data[((s*3)+2)*13+1] = nccp[d2*shapencc[1]+i];
			//cost sad
			features_data[((s*3)+2)*13+2] = sadp[d2*shapesad[1]+i];

			//PKRN CENSUS
			features_data[((s*3)+2)*13+3] = ( min_cens +.01 ) / (censp[pos+d2]+.01);
			assert(  ( min_cens +.01 ) / (censp[pos+d2]+.01) > 0);
			//PKRN NCC
			features_data[((s*3)+2)*13+4] = ( min_ncc +1.01 ) / (nccp[d2*shapencc[1]+i]+1.01);
			assert( ( min_ncc +1.01 ) / (nccp[d2*shapencc[1]+i]+1.01)>0);
			//PKRN SAD
			features_data[((s*3)+2)*13+5] = ( min_sad +.01 ) / (sadp[d2*shapesad[1]+i]+.01);
			assert( ( min_sad +.01 ) / (sadp[d2*shapesad[1]+i]+.01)>0);


			//MMN CENSUS
			features_data[((s*3)+2)*13+6] = censp[pos+d2] - min_cens;
			//MMN NCC
			features_data[((s*3)+2)*13+7] = nccp[d2*shapencc[1]+i] - min_ncc;
			//MMN SAD
			features_data[((s*3)+2)*13+8] = sadp[d2*shapesad[1]+i] - min_sad;

			//AML CENSUS
			features_data[((s*3)+2)*13+9] = exp( -((features_data[((s*3)+2)*13+6]*features_data[((s*3)+2)*13+6]) /CENSUSSIGMA )) /censdenom ;
			//AML NCC
			features_data[((s*3)+2)*13+10] = exp( -((features_data[((s*3)+2)*13+7]*features_data[((s*3)+2)*13+7]) /NCCSIGMA )) /nccdenom ;
			//AML SAD
			features_data[((s*3)+2)*13+11] = exp( -((features_data[((s*3)+2)*13+8]*features_data[((s*3)+2)*13+8]) /SADSIGMA )) /saddenom ;
			//label
			features_data[((s*3)+2)*13+12] = 0;


		}
	}

	return features;
}




PyObject* swap_axes(PyObject* cost ){


    PyArrayObject* costA = reinterpret_cast<PyArrayObject*>(cost);
    double * costp = reinterpret_cast<double*>(PyArray_DATA(costA));
    npy_intp *shape = PyArray_DIMS(costA);

    npy_intp *res_shape = new npy_intp[3];
    res_shape[0] = shape[1]; res_shape[1] = shape[2], res_shape[2] = shape[0] ;


	PyObject* res = PyArray_SimpleNew(3, res_shape, NPY_FLOAT64);

	double* res_data = static_cast<double*>(PyArray_DATA(reinterpret_cast<PyArrayObject*>(res)));

#pragma omp parallel num_threads(12)
	{
		#pragma omp for
		for(int i=0; i<res_shape[0]*res_shape[1]; i++){
			for(int j=0; j<res_shape[2]; j++){

				res_data[ i*res_shape[2] +j ] = costp[ j*res_shape[0]*res_shape[1] +i];
			}
		}
	}

	return res;
}

PyObject* get_cost(PyObject* cost ){


    PyArrayObject* costA = reinterpret_cast<PyArrayObject*>(cost);
    double * costp = reinterpret_cast<double*>(PyArray_DATA(costA));
    npy_intp *shape = PyArray_DIMS(costA);

    npy_intp *res_shape = new npy_intp[3];
    res_shape[0] = shape[2]; res_shape[1] = shape[0], res_shape[2] = shape[1] ;


	PyObject* res = PyArray_SimpleNew(3, res_shape, NPY_FLOAT64);

	double* res_data = static_cast<double*>(PyArray_DATA(reinterpret_cast<PyArrayObject*>(res)));

#pragma omp parallel num_threads(12)
	{
		#pragma omp for
		for(int i=0; i<shape[0]*shape[1]; i++){
			for(int j=0; j<shape[2]; j++){

				res_data[ j*shape[0]*shape[1] +i ] = costp[ i*shape[2]*shape[3] +j*shape[3]];
			}
		}
	}

	return res;
}

PyObject* get_right_cost(PyObject* cost ){


    PyArrayObject* costA = reinterpret_cast<PyArrayObject*>(cost);
    double * costp = reinterpret_cast<double*>(PyArray_DATA(costA));
    npy_intp *shape = PyArray_DIMS(costA);

    npy_intp *res_shape = new npy_intp[3];
    res_shape[0] = shape[0]; res_shape[1] = shape[1], res_shape[2] = shape[2] ;


	PyObject* res = PyArray_SimpleNew(3, res_shape, NPY_FLOAT64);

	double* res_data = static_cast<double*>(PyArray_DATA(reinterpret_cast<PyArrayObject*>(res)));
	int fill_size = shape[0]*shape[1]*shape[2];
	std::fill_n(res_data,fill_size, costp[0]);

#pragma omp parallel num_threads(12)
	{
		#pragma omp for
		for(int d=0; d<shape[0]; d++){
			for(int i=0; i<shape[1]; i++){

				for(int j=0; j<(shape[2]-d); j++){

					res_data[ d*shape[1]*shape[2] +i*shape[2] + j ] = costp[  d*shape[1]*shape[2] +i*shape[2] + (j+d) ] ;

				}

			}
		}
	}

	return res;
}


BOOST_PYTHON_MODULE(libfeatextract) {

	omp_set_num_threads(12);
    numeric::array::set_module_and_type("numpy", "ndarray");


    def("extract_features",extract_features);
    def("extract_features_old",extract_features_old);
    def("extract_testing_features",extract_testing_features);
    def("get_cost", get_cost);
    def("get_right_cost", get_right_cost);
    def("swap_axes", swap_axes);

    import_array();
}
