//============================================================================
// Name        : features.cpp
// Author      : 
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================


#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION

#include <iostream>
#include <boost/python.hpp>
#include "boost/python/extract.hpp"
#include "boost/python/numeric.hpp"
#include <numpy/ndarrayobject.h>

using namespace std;
using namespace boost::python;


PyObject* mmn(PyObject* cost){
    // Cast to pointer to Python Array object
    PyArrayObject* costA = reinterpret_cast<PyArrayObject*>(cost);

    //Get the pointer to the data
    float * costp = reinterpret_cast<float*>(PyArray_DATA(costA));





    npy_intp *shape = PyArray_DIMS(costA);
    npy_intp *resShape= new npy_intp[2];
    resShape[0] = shape[0]; resShape[1] = shape[1];


    PyObject* res = PyArray_SimpleNew(2, resShape, NPY_FLOAT);

    float* res_data = static_cast<float*>(PyArray_DATA(reinterpret_cast<PyArrayObject*>(res)));

    int disp;

    std::cout << shape[0] << " " << shape[1] << " " << shape[2] << std::endl;

	#pragma omp for
	for(int i=0; i<shape[0]; i++){
		for(int j=0; j<shape[1]; j++){
			float mincost = RAND_MAX;
			float min2cost = RAND_MAX;
			for(int k=0; k< shape[2]; k++){
				int index = i*shape[1]*shape[2] + j*shape[2] +k;
				if( costp[ index ] < mincost ){
					min2cost = mincost;
					mincost = costp[ index ];
				}
				else if( costp[ index ] < min2cost )
					min2cost = costp[ index ];

			}

				res_data[i*shape[1]+j] = min2cost-mincost;

		}
	}


	return res;


}

PyObject* DD(PyObject* dm){
	PyArrayObject* dmA = reinterpret_cast<PyArrayObject*>(dm);

	float * dmp = reinterpret_cast<float*>(PyArray_DATA(dmA));

	npy_intp *shape = PyArray_DIMS(dmA);


	PyObject* res = PyArray_SimpleNew(2,PyArray_DIMS(dmA), NPY_FLOAT);
	float* res_data = static_cast<float*>(PyArray_DATA(reinterpret_cast<PyArrayObject*>(res)));

	bool* ddmap = (bool *)calloc((int)shape[0]*shape[1],sizeof(bool));

    for(int j=0; j<shape[1]; j++){
            ddmap[j] = true;
            ddmap[(shape[0]-1)*(shape[1]-1)+j] = true;
    }

    for(int i=0;i<shape[0];i++){
            ddmap[i*shape[1]] = true;
            ddmap[i*shape[1]+(shape[0]-1)] = true;
    }


	#pragma omp parallel
	{

			#pragma omp for
			for(int i=1; i<shape[0]-1; i++){
					for(int j=1; j<shape[1]-1; j++){
							float val = dmp[i*shape[1]+j];

							if(fabs( dmp[(i-1)*shape[1]+j] - val ) > 1 ||
							   fabs( dmp[(i+1)*shape[1]+j] - val ) > 1 ||
							   fabs( dmp[i*shape[1]+(j-1)] - val ) > 1 ||
							   fabs( dmp[i*shape[1]+(j+1)] - val ) > 1){
								ddmap[i*shape[1]+j] = true;

							}

					}
			}

	}


	#pragma omp parallel
	{

			#pragma omp for
			for(int i=1; i<shape[0]-1; i++){
					for(int j=1; j<shape[1]-1; j++){

							if(ddmap[i*shape[1]+j]){
								res_data[ i*shape[1]+j ] =0;
								res_data[ i*shape[1]+j ] =0;
								res_data[ i*shape[1]+j ] =0;
								res_data[ i*shape[1]+j ] =0;
								continue;
							}


							int leftdist=0;
							for(int k=j; k>=0;k--){
									if(ddmap[i*shape[1]+k]){
											leftdist=j-k;
											break;
									}

							}
							int rightdist=0;
							for(int k=j; k<shape[1];k++){
									if(ddmap[i*shape[1]+k]){
											rightdist=k-j;
											break;
									}
							}

//							int topdist=0;
//							for(int k=i; k>=0;k--){
//									if(ddmap[k*shape[1]+j]){
//											topdist=i-k;
//											break;
//									}
//							}
//
//							int bottomdist=0;
//							for(int k=i; k<shape[1];k++){
//									if(ddmap[k*shape[1]+j]){
//											bottomdist =k-i;
//											break;
//									}
//							}


							int min = leftdist;

							if(rightdist < min)
								min = rightdist;
//							if(topdist < min)
//								min = topdist;
//							if(bottomdist < min)
//								min = bottomdist;

							res_data[ i*shape[1]+j] = min;


					}
			}

	}

delete [] ddmap;

return res;

}

PyObject* lrc(PyObject* left, PyObject *right){
    // Cast to pointer to Python Array object
    PyArrayObject* leftA = reinterpret_cast<PyArrayObject*>(left);
    PyArrayObject* rightA = reinterpret_cast<PyArrayObject*>(right);

    //Get the pointer to the data
    float * leftp = reinterpret_cast<float*>(PyArray_DATA(leftA));
    float * rightp = reinterpret_cast<float*>(PyArray_DATA(rightA));

    npy_intp *shape = PyArray_DIMS(leftA);

    PyObject* res = PyArray_SimpleNew(2, PyArray_DIMS(leftA), NPY_FLOAT);

    float* res_data = static_cast<float*>(PyArray_DATA(reinterpret_cast<PyArrayObject*>(res)));

    int disp;

	#pragma omp for
	for(int i=0; i<shape[0]; i++){
		for(int j=0; j<shape[1]; j++){
			disp = round(leftp[i*shape[1]+j]);
			res_data[i*shape[1]+j] = fabs( leftp[i*shape[1]+j] - rightp[i*shape[1]+(j-disp)] );
		}
	}


	// res = PyArray_Cast(reinterpret_cast<PyArrayObject*>(res), NPY_FLOAT32);

	//Py_DECREF(leftA);
	//Py_DECREF(rightp);


	return res;


}


BOOST_PYTHON_MODULE(features) {

    numeric::array::set_module_and_type("numpy", "ndarray");



    def("lrc",lrc);
    def("dd",DD);
    def("mmn",mmn);


    import_array();
}
